<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Random Maze – ブラウザでそのまま遊べる版</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Arial, sans-serif; background:#0b1220; color:#e5e7eb; }
    .wrap { min-height: 100%; display: grid; place-items: center; padding: 16px; }
    .card { width: min(92vw, 960px); }
    .bar { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .group { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn { appearance: none; border:1px solid #6b7280; background:#0f172a; color:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .num { width: 80px; padding:6px 8px; border-radius:10px; border:1px solid #475569; background:#0f172a; color:#fff; }
    .stat { font-size:14px; color:#cbd5e1; }
    .best { text-align:right; }
    .board { position: relative; border-radius:16px; overflow:hidden; box-shadow: 0 10px 30px rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08); }
    canvas { display:block; width:min(92vw, 560px); height:auto; touch-action: none; }
    .notice { margin-top:10px; font-size:13px; color:#94a3b8; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="bar">
        <div>
          <div style="font-size:20px; font-weight:800;">🌀 Random Maze – ブラウザ即実行</div>
          <div class="stat">WASD / 矢印キー ＋ スワイプで移動。スタート(左上) → ゴール(右下)。</div>
        </div>
        <div class="best">
          <div class="stat">BEST <span id="bestSize"></span></div>
          <div id="bestVal" style="font-weight:700;">--</div>
        </div>
      </div>

      <div class="board">
        <canvas id="maze" width="560" height="560"></canvas>
      </div>

      <div class="bar" style="margin-top:10px;">
        <div class="stat">経過: <b id="time">00:00.00</b> ／ ステップ: <b id="steps">0</b></div>
        <div class="group">
          <label class="stat">サイズ</label>
          <input id="cols" class="num" type="number" min="5" max="51" value="15" />
          <span class="stat">×</span>
          <input id="rows" class="num" type="number" min="5" max="51" value="15" />
          <button id="apply" class="btn">サイズ変更</button>
          <button id="regen" class="btn">Regenerate</button>
        </div>
      </div>

      <div class="notice">このHTMLファイルをそのまま開けば動きます。GitHub Pages / Vercel / Netlify / itch.io にアップするだけで共有OK。</div>
    </div>
  </div>

  <script>
    // ===== Utility =====
    const $ = (s)=>document.querySelector(s);
    const clamp = (n, a, b)=>Math.max(a, Math.min(b, n));
    const pretty = (ms)=>{
      const s = Math.floor(ms/1000); const cs = Math.floor((ms%1000)/10);
      return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
    };

    // ===== Maze generation (DFS backtracker) =====
    function carveMaze(cols, rows){
      const cells = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>({visited:false, walls:[true,true,true,true]})));
      const stack=[{x:0,y:0}];
      cells[0][0].visited=true;
      const DIR=[{dx:0,dy:-1,a:0,b:2},{dx:1,dy:0,a:1,b:3},{dx:0,dy:1,a:2,b:0},{dx:-1,dy:0,a:3,b:1}];
      while(stack.length){
        const cur = stack[stack.length-1];
        const neigh=[];
        for(const d of DIR){
          const nx=cur.x+d.dx, ny=cur.y+d.dy;
          if(nx>=0&&ny>=0&&nx<cols&&ny<rows&&!cells[ny][nx].visited){ neigh.push({nx,ny,d}); }
        }
        if(!neigh.length){ stack.pop(); continue; }
        const pick = neigh[(Math.random()*neigh.length)|0];
        cells[cur.y][cur.x].walls[pick.d.a]=false;
        cells[pick.ny][pick.nx].walls[pick.d.b]=false;
        cells[pick.ny][pick.nx].visited=true;
        stack.push({x:pick.nx,y:pick.ny});
      }
      return cells;
    }

    // ===== Draw =====
    const CANVAS_W=560, CANVAS_H=560;
    const canvas = $('#maze');
    const ctx = canvas.getContext('2d');

    function drawMaze(grid, player, goal, cellSize){
      // HiDPI scale (keep logical coords)
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      const cssW = Math.min(canvas.parentElement.clientWidth, CANVAS_W);
      canvas.style.width = cssW + 'px';
      canvas.style.height = (cssW*(CANVAS_H/CANVAS_W)) + 'px';
      canvas.width = CANVAS_W * dpr;
      canvas.height = CANVAS_H * dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0);

      const cols = grid[0].length, rows = grid.length;
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

      const g = ctx.createLinearGradient(0,0,0,CANVAS_H);
      g.addColorStop(0,'#0ea5e9'); g.addColorStop(1,'#0f172a');
      ctx.fillStyle=g; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

      const mazeW=cols*cellSize, mazeH=rows*cellSize;
      const offX=Math.floor((CANVAS_W - mazeW)/2), offY=Math.floor((CANVAS_H - mazeH)/2);

      ctx.fillStyle='#0b1220'; ctx.fillRect(offX-2, offY-2, mazeW+4, mazeH+4);
      ctx.fillStyle='#1e293b'; ctx.fillRect(offX, offY, mazeW, mazeH);

      ctx.strokeStyle='#94a3b8'; ctx.lineWidth=3; ctx.lineCap='round';
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const cell=grid[y][x]; const cx=offX+x*cellSize; const cy=offY+y*cellSize;
          if(cell.walls[0]){ ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+cellSize,cy); ctx.stroke(); }
          if(cell.walls[1]){ ctx.beginPath(); ctx.moveTo(cx+cellSize,cy); ctx.lineTo(cx+cellSize,cy+cellSize); ctx.stroke(); }
          if(cell.walls[2]){ ctx.beginPath(); ctx.moveTo(cx,cy+cellSize); ctx.lineTo(cx+cellSize,cy+cellSize); ctx.stroke(); }
          if(cell.walls[3]){ ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx,cy+cellSize); ctx.stroke(); }
        }
      }

      // goal
      const gx=offX + goal.x*cellSize, gy=offY + goal.y*cellSize;
      ctx.fillStyle='#10b981'; ctx.fillRect(gx+4, gy+4, cellSize-8, cellSize-8);
      // player
      const px=offX + player.x*cellSize + cellSize/2, py=offY + player.y*cellSize + cellSize/2;
      ctx.beginPath(); ctx.arc(px,py, Math.min(10, cellSize*0.35), 0, Math.PI*2); ctx.fillStyle='#f59e0b'; ctx.fill();
    }

    // ===== Game state =====
    let cols = 15, rows = 15;
    let grid = carveMaze(cols, rows);
    let player = {x:0, y:0};
    let goal = {x: cols-1, y: rows-1};
    let moves = 0; let startAt = Date.now(); let won=false;
    let timerId = null; let timeMs = 0;

    function cellSize(){ return Math.floor(Math.min(CANVAS_W, CANVAS_H) / Math.max(cols, rows)); }

    function startTimer(){
      stopTimer(); startAt = Date.now(); timerId = setInterval(()=>{ timeMs = Date.now()-startAt; $('#time').textContent = pretty(timeMs); }, 50);
    }
    function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } }

    function updateBest(){
      const key = `maze_best_${cols}x${rows}`;
      const prev = localStorage.getItem(key);
      const best = prev? JSON.parse(prev): null;
      $('#bestSize').textContent = `(${cols}×${rows})`;
      $('#bestVal').textContent = best? `${pretty(best.timeMs)} / ${best.moves}steps` : '--';
      return {key, best};
    }

    function saveBestIfNeeded(){
      const {key, best} = updateBest();
      if(!best || timeMs < best.timeMs){
        localStorage.setItem(key, JSON.stringify({ timeMs, moves, cols, rows, at: Date.now() }));
        updateBest();
      }
    }

    function draw(){ drawMaze(grid, player, goal, cellSize()); }

    function regenerate(newC=cols, newR=rows){
      cols = clamp(newC|0, 5, 51); rows = clamp(newR|0, 5, 51);
      grid = carveMaze(cols, rows);
      player = {x:0, y:0}; goal = {x:cols-1, y:rows-1}; moves = 0; won=false; timeMs = 0;
      $('#steps').textContent = moves; $('#time').textContent = pretty(0);
      updateBest(); startTimer(); draw();
    }

    // Init
    updateBest(); startTimer(); draw();

    // ===== Controls =====
    function tryMove(dx, dy){
      if(won) return;
      const x=player.x, y=player.y; const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=cols||ny>=rows) return;
      const cell = grid[y][x];
      if(dx===1 && cell.walls[1]) return;
      if(dx===-1 && cell.walls[3]) return;
      if(dy===1 && cell.walls[2]) return;
      if(dy===-1 && cell.walls[0]) return;
      player={x:nx,y:ny}; moves++; $('#steps').textContent = moves; draw();
      if(nx===goal.x && ny===goal.y){ won=true; stopTimer(); saveBestIfNeeded(); }
    }

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(['arrowup','w'].includes(k)){ e.preventDefault(); tryMove(0,-1); }
      else if(['arrowright','d'].includes(k)){ e.preventDefault(); tryMove(1,0); }
      else if(['arrowdown','s'].includes(k)){ e.preventDefault(); tryMove(0,1); }
      else if(['arrowleft','a'].includes(k)){ e.preventDefault(); tryMove(-1,0); }
    }, {passive:false});

    // Swipe (touch)
    let sx=0, sy=0;
    canvas.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
    canvas.addEventListener('touchend', (e)=>{
      e.preventDefault();
      const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
      const ax=Math.abs(dx), ay=Math.abs(dy);
      if(Math.max(ax,ay) < 18) return; // ignore tiny taps
      if(ax>ay) tryMove(dx>0?1:-1, 0); else tryMove(0, dy>0?1:-1);
    }, {passive:false});

    // UI wires
    $('#regen').addEventListener('click', ()=>regenerate(cols, rows));
    $('#apply').addEventListener('click', ()=>{
      regenerate(parseInt($('#cols').value,10), parseInt($('#rows').value,10));
    });

    // Resize redraw
    window.addEventListener('resize', draw);
  </script>
</body>
</html>
